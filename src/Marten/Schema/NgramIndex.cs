using System.Reflection;
using System.Text.RegularExpressions;

using Baseline;

using Marten.Storage;

namespace Marten.Schema
{
    /// <summary>
    /// Implements an index that extracts ngrams for the specified field.
    /// </summary>
    public class NgramIndex : IIndexDefinition
    {
        public const string DefaultDataConfig = "data";

        private string _dataConfig;
        private readonly DbObjectName _table;
        private string _indexName;

        public NgramIndex(DocumentMapping mapping, string dataConfig = null, string indexName = null)
        {
            _table = mapping.Table;
            DataConfig = dataConfig;
            IndexName = indexName;
        }

        public NgramIndex(DocumentMapping mapping, MemberInfo member)
            : this(mapping, GetDataConfig(mapping, member))
        {
        }

        /// <summary>
        /// Gets or sets the index name.
        /// </summary>
        public string IndexName
        {
            get
            {
                var lowerValue = _indexName?.ToLowerInvariant();
                if (lowerValue?.StartsWith(DocumentMapping.MartenPrefix) == true)
                {
                    return lowerValue.ToLowerInvariant();
                }

                if (lowerValue?.IsNotEmpty() == true)
                {
                    return DocumentMapping.MartenPrefix + lowerValue.ToLowerInvariant();
                }

                return $"{_table.Name}_idx_ngram_{_dataConfig}";
            }

            set => _indexName = value;
        }

        /// <summary>
        /// Gets or sets the data config.
        /// </summary>
        public string DataConfig
        {
            get => _dataConfig;
            set => _dataConfig = value ?? DefaultDataConfig;
        }

        /// <summary>
        /// Returns the definition for the index.
        /// </summary>
        /// <returns>
        /// The DDL for the index.
        /// </returns>
        public string ToDDL()
        {
            return $"CREATE INDEX {IndexName}_{_dataConfig} ON {_table.QualifiedName} USING gin (( mt_grams_vector( {_dataConfig}) ));";
        }

        public bool Matches(ActualIndex index)
        {
            var ddl = index?.DDL.ToLowerInvariant();

            // To omit the null conditional operators that were following here before
            if (ddl == null)
            {
                return false;
            }

            var regexStripType = new Regex(@"('.+?')::text");
            var regexStripParentheses = new Regex("[()]");

            // Check for the existence of the 'mt_grams_vector' function, the correct table name, and the use of the data column
            return ddl.Contains("mt_grams_vector") == true
                && ddl.Contains(IndexName) == true
                && ddl.Contains(_table.QualifiedName) == true
                // For comparison, strip out types (generated by pg_get_indexdef, but not by Marten) and parentheses (again, pg_get_indexdef produces a bit different output to Marten).
                && regexStripParentheses.Replace(regexStripType.Replace(ddl, "$1"), string.Empty).Contains(regexStripParentheses.Replace(_dataConfig.ToLowerInvariant(), string.Empty));
        }

        private static string GetDataConfig(DocumentMapping mapping, MemberInfo member)
        {
            var dataConfig = mapping.FieldFor(member).SqlLocator.Replace("d.", "");

            return dataConfig;
        }

        private void RefreshIndexName()
        {
            IndexName = _indexName;
        }
    }
}
